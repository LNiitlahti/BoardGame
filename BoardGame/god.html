<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>God Mode - Board Game Admin</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        /* Additional styles specific to god mode */
        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
        }

        .connection-status.connected {
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid #4ade80;
            color: #4ade80;
        }

        .connection-status.disconnected {
            background: rgba(248, 113, 113, 0.2);
            border: 1px solid #f87171;
            color: #f87171;
        }

        /* Board container needs proper wrapper structure */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .hex-board-wrapper {
            position: relative;
            width: 100%;
            height: 700px;
            overflow: hidden;
        }

        /* Highlighting for valid placements - targets the ::before pseudo-element */
        .board-hex.can-place-highlight::before {
            background: rgba(74, 222, 128, 0.9) !important;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.8);
            animation: pulse-highlight 1.5s ease-in-out infinite;
        }

        @keyframes pulse-highlight {
            0%, 100% { 
                opacity: 0.8;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.05);
            }
        }

        /* Game Queue Styles */
        .queue-container {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .queued-game {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .queued-game:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .queued-game.pending {
            border-left-color: #60a5fa;
        }

        .queued-game.ready {
            border-left-color: #4ade80;
        }

        /* Plan Game Interface */
        .plan-game-container {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            min-height: 250px;
        }

        .team-pool {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            max-height: 400px;
            overflow-y: auto;
        }

        .team-pool h4 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1rem;
            sticky: top;
            background: inherit;
            padding-bottom: 10px;
        }

        .team-slots-container {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .team-slot {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 10px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            min-height: 80px;
            transition: all 0.3s ease;
            position: relative;
        }

        .team-slot.drag-over {
            background: rgba(74, 222, 128, 0.2);
            border-color: #4ade80;
        }

        .team-slot h5 {
            margin-bottom: 8px;
            color: #ffd700;
            font-size: 0.9rem;
        }

        .team-slot.slot-0 { border-color: rgba(59, 130, 246, 0.5); }
        .team-slot.slot-1 { border-color: rgba(239, 68, 68, 0.5); }
        .team-slot.slot-2 { border-color: rgba(34, 197, 94, 0.5); }
        .team-slot.slot-3 { border-color: rgba(251, 146, 60, 0.5); }

        .team-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: move;
            border-left: 4px solid;
            transition: all 0.3s ease;
            position: relative;
        }

        .team-box:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(3px);
        }

        .team-box.dragging {
            opacity: 0.5;
        }

        .team-box.team1 { border-left-color: #ff4444; }
        .team-box.team2 { border-left-color: #44ff44; }
        .team-box.team3 { border-left-color: #4444ff; }
        .team-box.team4 { border-left-color: #ffff44; }
        .team-box.team5 { border-left-color: #ff44ff; }

        .team-box.in-slot {
            cursor: default;
        }

        .remove-team {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(239, 68, 68, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            padding: 0;
        }

        .remove-team:hover {
            background: rgba(239, 68, 68, 1);
        }

        .team-name {
            font-weight: 600;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
        }

        .players-container {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .player-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.8rem;
            cursor: move;
            transition: all 0.2s ease;
            display: inline-block;
            margin: 2px;
        }

        .player-tag:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .player-tag.dragging {
            opacity: 0.5;
        }

        .team-box.team1 .player-tag { background: rgba(255, 68, 68, 0.4); border: 1px solid rgba(255, 68, 68, 0.6); }
        .team-box.team2 .player-tag { background: rgba(68, 255, 68, 0.4); border: 1px solid rgba(68, 255, 68, 0.6); }
        .team-box.team3 .player-tag { background: rgba(68, 68, 255, 0.4); border: 1px solid rgba(68, 68, 255, 0.6); }
        .team-box.team4 .player-tag { background: rgba(255, 255, 68, 0.4); border: 1px solid rgba(255, 255, 68, 0.6); }
        .team-box.team5 .player-tag { background: rgba(255, 68, 255, 0.4); border: 1px solid rgba(255, 68, 255, 0.6); }

        /* Editable player names */
        .editable-player-name {
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .editable-player-name:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .editable-player-name.editing {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #ffd700;
            outline: none;
        }

        /* Manual game setup - player-based drop zones */
        .player-drop-zone {
            min-height: 100px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .player-drop-zone.drag-over {
            background: rgba(74, 222, 128, 0.2);
            border-color: #4ade80;
        }

        .player-drop-zone.team-a {
            border-color: rgba(59, 130, 246, 0.5);
        }

        .player-drop-zone.team-b {
            border-color: rgba(239, 68, 68, 0.5);
        }

        .assigned-player {
            display: inline-block;
            padding: 6px 10px;
            margin: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            font-size: 0.85rem;
            position: relative;
            padding-right: 25px;
        }

        .assigned-player .remove-player {
            position: absolute;
            top: 2px;
            right: 4px;
            background: rgba(239, 68, 68, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
            padding: 0;
        }

        /* Confirm Result Interface */
        .confirm-container {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-top: 15px;
        }

        .teams-display {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .winner-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
            cursor: pointer;
        }

        .winner-label {
            cursor: pointer;
            user-select: none;
        }

        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .plan-game-container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="connectionStatus" class="connection-status disconnected">üî¥ Connecting to Firebase...</div>
    
    <div class="container">
        <div class="header">
            <h1>üëë God Mode - Admin Panel</h1>
            <p>Complete control over the board game system</p>
        </div>

        <div class="status-message" id="statusMessage"></div>

        <div class="main-grid">
            <!-- Left Sidebar: Player Management & Controls -->
            <div>
                <div class="panel">
                    <h3>üë• Player & Team Management</h3>
                    <div class="form-group">
                        <label>Game ID</label>
                        <input type="text" id="gameId" placeholder="game-session-id">
                        <button class="btn" onclick="loadGame()" style="margin-top: 5px;">üìÇ Load Game</button>
                    </div>
                    
                    <div id="playerManagementSection" style="display: none; margin-top: 15px;">
                        <label style="display: block; margin-bottom: 10px; color: #ffd700; font-weight: 600;">
                            Teams & Players (click name to edit)
                        </label>
                        <div id="playersList" style="max-height: 300px; overflow-y: auto;">
                            <!-- Players list will be rendered here -->
                        </div>
                    </div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <h3>üìä Game Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-number" id="statGamesPlayed">0</div>
                            <div class="stat-label">Games Played</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="statRound">0</div>
                            <div class="stat-label">Current Round</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="statPlates">0</div>
                            <div class="stat-label">Plates on Board</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="statHearts">0</div>
                            <div class="stat-label">Hearts Controlled</div>
                        </div>
                    </div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <h3>üéØ Game Management</h3>
                    
                    <!-- Tab Buttons -->
                    <div class="tab-buttons">
                        <button class="tab-btn active" onclick="switchTab('plan')">üìã Plan Game</button>
                        <button class="tab-btn" onclick="switchTab('confirm')">‚úÖ Confirm Result</button>
                    </div>

                    <!-- Plan Game Tab -->
                    <div id="planTab" class="tab-content active">
                        <div class="form-group">
                            <label>Game Type</label>
                            <select id="planGameType">
                                <option value="CS2">Counter-Strike 2</option>
                                <option value="Dota2">Dota 2</option>
                                <option value="Valorant">Valorant</option>
                                <option value="StarCraft2">StarCraft 2</option>
                                <option value="Predecessor">Predecessor</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Match Type</label>
                            <select id="planPlayType">
                                <option value="1v1">1v1</option>
                                <option value="2v2">2v2</option>
                                <option value="3v3">3v3</option>
                                <option value="5v5">5v5</option>
                            </select>
                        </div>

                        <label style="color: #ffd700; font-weight: 600; display: block; margin-bottom: 10px;">
                            Build Match (drag players or whole teams)
                        </label>

                        <!-- Player-based drag and drop -->
                        <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                            <div style="flex: 1;">
                                <div class="player-drop-zone team-a" 
                                     ondrop="dropPlayer(event, 'TEAM_A')" 
                                     ondragover="allowDrop(event)" 
                                     ondragleave="dragLeave(event)">
                                    <h5 style="color: #3b82f6; margin-bottom: 8px;">TEAM A</h5>
                                    <div id="teamAPlayers" style="min-height: 60px;">
                                        <span style="opacity: 0.6; font-size: 0.85rem;">Drop players here...</span>
                                    </div>
                                </div>
                            </div>

                            <div style="flex: 1;">
                                <div class="player-drop-zone team-b" 
                                     ondrop="dropPlayer(event, 'TEAM_B')" 
                                     ondragover="allowDrop(event)" 
                                     ondragleave="dragLeave(event)">
                                    <h5 style="color: #ef4444; margin-bottom: 8px;">TEAM B</h5>
                                    <div id="teamBPlayers" style="min-height: 60px;">
                                        <span style="opacity: 0.6; font-size: 0.85rem;">Drop players here...</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Available teams/players pool -->
                        <div class="team-pool" style="max-height: 300px;">
                            <h4>Available Teams & Players</h4>
                            <div id="planTeamPool"></div>
                        </div>

                        <div class="form-group" style="margin-top: 15px;">
                            <label>Notes (optional)</label>
                            <input type="text" id="planNotes" placeholder="Any special notes about this game...">
                        </div>
                        <button class="btn primary" onclick="addGameToQueue()">‚ûï Add to Queue</button>
                        <button class="btn" onclick="clearManualGameSetup()">üîÑ Clear</button>
                    </div>

                    <!-- Confirm Result Tab -->
                    <div id="confirmTab" class="tab-content">
                        <div class="form-group">
                            <label>Select Queued Game</label>
                            <select id="queuedGameSelect" onchange="loadQueuedGame()">
                                <option value="">-- Select a game to confirm --</option>
                            </select>
                        </div>

                        <div class="confirm-container" id="confirmContainer" style="display: none;">
                            <h4 style="color: #ffd700; margin-bottom: 10px;">Game Details</h4>
                            <div id="confirmGameInfo"></div>

                            <h4 style="color: #ffd700; margin-top: 15px; margin-bottom: 10px;">Select Winner(s)</h4>
                            <div id="confirmTeamsDisplay"></div>

                            <div class="form-group" style="margin-top: 15px;">
                                <label>Actual Result Notes (optional)</label>
                                <input type="text" id="confirmNotes" placeholder="Any additional notes about the result...">
                            </div>

                            <button class="btn primary" onclick="confirmGameResult()">‚úÖ Submit Result & Start Turn</button>
                        </div>
                    </div>
                </div>

                <!-- Game Queue Display -->
                <div class="panel" style="margin-top: 20px;">
                    <h3>üìã Game Queue (<span id="queueCount">0</span>)</h3>
                    <div class="queue-container" id="gameQueue">
                        <p style="text-align: center; opacity: 0.7; font-style: italic;">No games in queue</p>
                    </div>
                </div>
            </div>

            <!-- Center: Game Board -->
            <div class="board-container">
                <div class="panel" style="width: 100%;">
                    <h3 style="text-align: center;">üéØ Game Board</h3>
                    <div id="currentTurnInfo" style="text-align: center; padding: 15px; background: rgba(255, 215, 0, 0.2); border-radius: 10px; margin: 15px 0;">
                        <strong>‚è≥ No active turn</strong>
                    </div>
                    <div style="text-align: center; margin-bottom: 15px;">
                        <button class="btn" onclick="highlightValidPlacements()" style="width: auto; display: inline-block; margin: 5px;">
                            üîç Show Valid Placements
                        </button>
                        <button class="btn" onclick="clearHighlights()" style="width: auto; display: inline-block; margin: 5px;">
                            üßπ Clear Highlights
                        </button>
                    </div>
                </div>

                <div class="hex-board-wrapper">
                    <div id="hexBoard"></div>
                </div>

                <div class="panel" style="width: 100%;">
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; font-size: 0.85rem;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 20px; height: 18px; background: rgba(255, 215, 0, 0.5); clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);"></div>
                            Starting Corner
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 20px; height: 18px; background: rgba(255, 20, 147, 0.5); clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);"></div>
                            Heart Hex (+1/turn)
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 20px; height: 18px; background: rgba(138, 43, 226, 0.5); clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);"></div>
                            Mountain Heart (+2/turn)
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 20px; height: 18px; background: rgba(0, 255, 0, 0.4); clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);"></div>
                            Can Place Here
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar: Teams & Activity -->
            <div>
                <div class="panel">
                    <h3>üë• Team Rankings</h3>
                    <div id="teamsList">
                        <p style="text-align: center; opacity: 0.7; font-style: italic;">Initialize game to see teams</p>
                    </div>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <h3>üìú Game Log</h3>
                    <div class="game-log" id="gameLog">
                        <div class="log-entry">System initialized. Ready to start.</div>
                    </div>
                    <button class="btn" onclick="clearLog()" style="margin-top: 10px;">üóëÔ∏è Clear Log</button>
                </div>

                <div class="panel" style="margin-top: 20px;">
                    <h3>üíæ Data Management</h3>
                    <button class="btn" onclick="exportGameState()">üì• Export Game State</button>
                    <button class="btn" onclick="saveGameState()">üíæ Save to Firebase</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Load board modules first -->
    <script src="scripts/board-module.js"></script>
    <script src="scripts/board-renderer.js"></script>
    
    <!-- Firebase SDK - Using the loader pattern -->
    <script src="scripts/firebase-loader.js"></script>

    <script>
        // ===== GLOBAL STATE =====
        let gameState = null;
        let activeListener = null;
        
        // Manual game setup - player-based (NOT planGameSetup!)
        let manualGameSetup = {
            teamA: [],
            teamB: []
        };
        
        let selectedQueuedGame = null;
        
        // Board rendering instances
        let boardModule = null;
        let boardRenderer = null;

        // Initialize board modules
        function initializeBoardModules() {
            boardModule = new BoardModule(1);
            const hexBoardContainer = document.getElementById('hexBoard');
            boardRenderer = new BoardRenderer(hexBoardContainer, boardModule, {
                responsive: true
            });
        }

        // ===== FIREBASE CONNECTION =====
        document.addEventListener('firebase-ready', function() {
            document.getElementById('connectionStatus').className = 'connection-status connected';
            document.getElementById('connectionStatus').textContent = 'üü¢ Firebase Connected';
            addLog('Firebase connected successfully', 'success');
        });

        window.addEventListener('load', function() {
            setTimeout(() => {
                if (window.firebaseDB) {
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                    document.getElementById('connectionStatus').textContent = 'üü¢ Firebase Connected';
                    addLog('Firebase connected successfully', 'success');
                }
            }, 2000);
        });

        // ===== UTILITY FUNCTIONS =====
        function cleanObject(obj) {
            if (obj === null || obj === undefined) {
                return null;
            }
            
            if (Array.isArray(obj)) {
                return obj.map(item => cleanObject(item)).filter(item => item !== undefined);
            }
            
            if (typeof obj === 'object') {
                const cleaned = {};
                for (const key in obj) {
                    const value = cleanObject(obj[key]);
                    if (value !== undefined) {
                        cleaned[key] = value;
                    }
                }
                return cleaned;
            }
            
            return obj;
        }

        function getTeamColor(teamId) {
            const colors = {
                1: '#ff4444',
                2: '#44ff44', 
                3: '#4444ff',
                4: '#ffff44',
                5: '#ff44ff'
            };
            return colors[teamId] || '#888888';
        }

        // ===== TAB SWITCHING =====
        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            if (tab === 'plan') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('planTab').classList.add('active');
            } else {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('confirmTab').classList.add('active');
                updateQueuedGameSelect();
            }
        }

        // ===== GAME LOADING =====
        async function loadGame() {
            const gameId = document.getElementById('gameId').value.trim();
            if (!gameId) {
                showStatus('Please enter a Game ID', 'error');
                return;
            }
            
            try {
                const docRef = window.firebaseDoc(window.firebaseDB, 'games', gameId);
                
                if (activeListener) activeListener();
                
                activeListener = window.firebaseOnSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists) {
                        gameState = docSnap.data();
                        
                        if (!gameState.gameQueue) {
                            gameState.gameQueue = [];
                        }
                        
                        document.getElementById('playerManagementSection').style.display = 'block';
                        
                        updateDisplay();
                        renderPlanTeamPool();
                        renderPlayerManagement();
                        updateGameQueue();
                        addLog(`üìÇ Game "${gameId}" loaded`, 'success');
                        showStatus('Game loaded successfully!', 'success');
                    } else {
                        showStatus(`Game "${gameId}" not found`, 'error');
                    }
                });
            } catch (error) {
                console.error('Load error:', error);
                showStatus('Error loading game: ' + error.message, 'error');
            }
        }

        async function saveGameState() {
            if (!gameState?.gameId) return;
            
            try {
                const cleanedState = cleanObject(gameState);
                const docRef = window.firebaseDoc(window.firebaseDB, 'games', gameState.gameId);
                await window.firebaseSetDoc(docRef, cleanedState);
                addLog('üíæ Game state saved', 'success');
            } catch (error) {
                console.error('Save error:', error);
                showStatus('Error saving game: ' + error.message, 'error');
                addLog('Save error: ' + error.message, 'error');
            }
        }

        // ===== PLAYER MANAGEMENT =====
        function renderPlayerManagement() {
            const container = document.getElementById('playersList');
            
            if (!gameState?.teams) {
                container.innerHTML = '<p style="opacity: 0.7; text-align: center;">Load game to see players</p>';
                return;
            }
            
            container.innerHTML = gameState.teams.map(team => `
                <div style="margin-bottom: 15px; padding: 12px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 4px solid ${getTeamColor(team.id)};">
                    <div style="font-weight: 600; color: #ffd700; margin-bottom: 8px;">
                        ${team.name} (${team.points || 0} pts)
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${team.players.map((player, playerIndex) => {
                            return `
                                <span class="editable-player-name" 
                                      data-player-index="${playerIndex}"
                                      data-team-id="${team.id}"
                                      onclick="makePlayerNameEditable(this)"
                                      title="Click to edit">
                                    ${player.name}
                                </span>
                            `;
                        }).join('')}
                    </div>
                </div>
            `).join('');
        }

        function makePlayerNameEditable(element) {
            if (document.querySelector('.editing')) {
                console.log('Another element is already being edited');
                return;
            }
            
            const playerIndex = parseInt(element.dataset.playerIndex);
            const teamId = parseInt(element.dataset.teamId);
            const currentName = element.textContent.trim();
            
            console.log(`Starting edit for player at index ${playerIndex} (${currentName}) in team ${teamId}`);
            
            element.contentEditable = true;
            element.classList.add('editing');
            element.focus();
            
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            let hasFinished = false;
            
            const finishEdit = async function() {
                if (hasFinished) {
                    console.log('Already finished editing, skipping duplicate call');
                    return;
                }
                hasFinished = true;
                
                console.log('finishEdit called');
                
                const newName = element.textContent.trim();
                console.log(`New name: "${newName}", Old name: "${currentName}"`);
                
                element.contentEditable = false;
                element.classList.remove('editing');
                
                if (newName && newName !== currentName) {
                    console.log('Name changed, proceeding with update');
                    
                    try {
                        const team = gameState.teams.find(t => t.id === teamId);
                        console.log('Found team:', team);
                        
                        if (team && team.players[playerIndex]) {
                            const player = team.players[playerIndex];
                            console.log('Found player at index:', player);
                            
                            const oldName = player.name;
                            player.name = newName;
                            console.log(`Updated player object from "${oldName}" to "${newName}"`);
                            
                            if (player.id !== undefined && gameState.players) {
                                const globalPlayer = gameState.players.find(p => p.id === player.id);
                                if (globalPlayer) {
                                    globalPlayer.name = newName;
                                    console.log('Updated global player object');
                                }
                            }
                            
                            console.log('About to save to Firebase...');
                            await saveGameState();
                            console.log('Firebase save completed');
                            
                            addLog(`‚úèÔ∏è Renamed player: ${oldName} ‚Üí ${newName}`, 'success');
                            showStatus(`Player renamed to ${newName}`, 'success');
                            
                            console.log('Re-rendering UI sections...');
                            renderPlayerManagement();
                            renderPlanTeamPool();
                            updateTeamsList();
                            console.log('UI update complete');
                        } else {
                            console.error('Player not found at index:', playerIndex);
                            element.textContent = currentName;
                        }
                    } catch (error) {
                        console.error('Error updating player name:', error);
                        showStatus('Error updating player name: ' + error.message, 'error');
                        element.textContent = currentName;
                    }
                } else if (!newName) {
                    console.log('Empty name, restoring original');
                    element.textContent = currentName;
                } else {
                    console.log('Name unchanged, no update needed');
                }
            };
            
            const handleKeyDown = function(e) {
                console.log('Key pressed:', e.key);
                if (e.key === 'Enter') {
                    e.preventDefault();
                    console.log('Enter pressed, blurring element');
                    element.removeEventListener('keydown', handleKeyDown);
                    element.blur();
                }
            };
            
            element.addEventListener('keydown', handleKeyDown);
            
            element.addEventListener('blur', function blurHandler() {
                console.log('Blur event fired');
                element.removeEventListener('keydown', handleKeyDown);
                finishEdit();
            }, { once: true });
            
            console.log('Event listeners attached');
        }

        // ===== MANUAL GAME SETUP (DRAG AND DROP) =====
        function renderPlanTeamPool() {
            const pool = document.getElementById('planTeamPool');
            if (!gameState?.teams) {
                pool.innerHTML = '<p style="opacity: 0.7; text-align: center; font-size: 0.85rem;">Load game first</p>';
                return;
            }
            
            const assignedSignatures = [
                ...manualGameSetup.teamA.map(p => `${p.originalTeamId}-${p.name}`),
                ...manualGameSetup.teamB.map(p => `${p.originalTeamId}-${p.name}`)
            ];
            
            console.log('Rendering pool. Assigned signatures:', assignedSignatures);
            
            pool.innerHTML = gameState.teams.map(team => {
                const playersWithStatus = team.players.map((player, playerIndex) => {
                    const signature = `${team.id}-${player.name}`;
                    const isAssigned = assignedSignatures.includes(signature);
                    return { player, playerIndex, isAssigned };
                });
                
                const availablePlayers = playersWithStatus.filter(p => !p.isAssigned);
                
                return `
                    <div class="team-box team${team.id}" 
                         draggable="${availablePlayers.length > 0 ? 'true' : 'false'}" 
                         ondragstart="dragTeam(event, ${team.id})" 
                         ondragend="dragEnd(event)"
                         style="${availablePlayers.length === 0 ? 'opacity: 0.4; cursor: not-allowed;' : ''}">
                        <div class="team-name">
                            <span>${team.name}</span>
                            <span style="opacity: 0.7; font-size: 0.85rem;">${team.points || 0} pts</span>
                        </div>
                        <div class="players-container">
                            ${playersWithStatus.map(({player, playerIndex, isAssigned}) => {
                                return `
                                    <span class="player-tag ${isAssigned ? 'assigned' : ''}" 
                                          draggable="${!isAssigned ? 'true' : 'false'}"
                                          ondragstart="dragPlayer(event, ${playerIndex}, ${team.id})" 
                                          ondragend="dragEnd(event)"
                                          style="${isAssigned ? 'opacity: 0.3; cursor: not-allowed;' : ''}"
                                          title="${player.name}">
                                        ${player.name}
                                    </span>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function dragPlayer(event, playerIndex, teamId) {
            event.stopPropagation();
            event.target.classList.add('dragging');
            
            console.log('Dragging player - Index:', playerIndex, 'Team:', teamId);
            
            event.dataTransfer.setData('application/json', JSON.stringify({
                type: 'player',
                playerId: playerIndex,
                teamId: teamId
            }));
        }

        function dragTeam(event, teamId) {
            event.target.classList.add('dragging');
            
            event.dataTransfer.setData('application/json', JSON.stringify({
                type: 'team',
                teamId: teamId
            }));
        }

        function dragEnd(event) {
            event.target.classList.remove('dragging');
        }

        function allowDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.add('drag-over');
        }

        function dragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }

        function dropPlayer(event, targetTeam) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            
            console.log('=== DROP EVENT START ===');
            console.log('Target team:', targetTeam);
            console.log('Current TEAM A players:', manualGameSetup.teamA);
            console.log('Current TEAM B players:', manualGameSetup.teamB);
            
            const dragData = JSON.parse(event.dataTransfer.getData('application/json'));
            console.log('Drag data:', dragData);
            
            if (dragData.type === 'player') {
                console.log('Processing single player drop');
                
                const sourceTeam = gameState.teams.find(t => t.id === dragData.teamId);
                console.log('Source team:', sourceTeam);
                
                if (!sourceTeam) {
                    console.error('Source team not found!');
                    return;
                }
                
                const player = sourceTeam.players[dragData.playerId];
                console.log('Player at index:', player);
                
                if (!player) {
                    console.error('Player not found at index!');
                    return;
                }
                
                const playerSignature = `${dragData.teamId}-${player.name}`;
                console.log('Player signature:', playerSignature);
                
                const alreadyInA = manualGameSetup.teamA.some(p => 
                    p.originalTeamId === dragData.teamId && p.name === player.name
                );
                const alreadyInB = manualGameSetup.teamB.some(p => 
                    p.originalTeamId === dragData.teamId && p.name === player.name
                );
                
                console.log('Already in A:', alreadyInA);
                console.log('Already in B:', alreadyInB);
                
                if (alreadyInA || alreadyInB) {
                    console.log('Player already assigned, aborting');
                    showStatus('Player already assigned', 'error');
                    return;
                }
                
                const playerForGame = {
                    id: dragData.playerId,
                    name: player.name,
                    originalTeamId: dragData.teamId,
                    originalTeamName: sourceTeam.name
                };
                
                console.log('Created player object:', playerForGame);
                
                if (targetTeam === 'TEAM_A') {
                    console.log('Adding to TEAM A');
                    manualGameSetup.teamA.push(playerForGame);
                    console.log('TEAM A after push:', manualGameSetup.teamA);
                } else {
                    console.log('Adding to TEAM B');
                    manualGameSetup.teamB.push(playerForGame);
                    console.log('TEAM B after push:', manualGameSetup.teamB);
                }
                
            } else if (dragData.type === 'team') {
                console.log('Processing whole team drop');
                
                const sourceTeam = gameState.teams.find(t => t.id === dragData.teamId);
                console.log('Source team:', sourceTeam);
                
                if (!sourceTeam) {
                    console.error('Source team not found!');
                    return;
                }
                
                const assignedSignatures = [
                    ...manualGameSetup.teamA.map(p => `${p.originalTeamId}-${p.name}`),
                    ...manualGameSetup.teamB.map(p => `${p.originalTeamId}-${p.name}`)
                ];
                
                console.log('Currently assigned signatures:', assignedSignatures);
                
                const playersToAdd = sourceTeam.players
                    .map((p, index) => ({
                        id: index,
                        name: p.name,
                        originalTeamId: sourceTeam.id,
                        originalTeamName: sourceTeam.name,
                        signature: `${sourceTeam.id}-${p.name}`
                    }))
                    .filter(p => !assignedSignatures.includes(p.signature));
                
                console.log('Players to add:', playersToAdd);
                
                if (playersToAdd.length === 0) {
                    console.log('All players already assigned');
                    showStatus('All players from this team are already assigned', 'error');
                    return;
                }
                
                const cleanedPlayers = playersToAdd.map(({signature, ...rest}) => rest);
                
                if (targetTeam === 'TEAM_A') {
                    console.log('Adding to TEAM A');
                    manualGameSetup.teamA.push(...cleanedPlayers);
                    console.log('TEAM A after push:', manualGameSetup.teamA);
                } else {
                    console.log('Adding to TEAM B');
                    manualGameSetup.teamB.push(...cleanedPlayers);
                    console.log('TEAM B after push:', manualGameSetup.teamB);
                }
            }
            
            console.log('Calling updateManualGameDisplay...');
            updateManualGameDisplay();
            console.log('Calling renderPlanTeamPool...');
            renderPlanTeamPool();
            console.log('=== DROP EVENT END ===');
        }

        function updateManualGameDisplay() {
            const teamADiv = document.getElementById('teamAPlayers');
            const teamBDiv = document.getElementById('teamBPlayers');
            
            if (manualGameSetup.teamA.length === 0) {
                teamADiv.innerHTML = '<span style="opacity: 0.6; font-size: 0.85rem;">Drop players here...</span>';
            } else {
                teamADiv.innerHTML = manualGameSetup.teamA.map((player, index) => `
                    <div class="assigned-player">
                        ${player.name}
                        <span style="opacity: 0.6; font-size: 0.75rem; margin-left: 4px;">(${player.originalTeamName})</span>
                        <button class="remove-player" onclick="removePlayerFromSide('teamA', ${index})" title="Remove">√ó</button>
                    </div>
                `).join('');
            }
            
            if (manualGameSetup.teamB.length === 0) {
                teamBDiv.innerHTML = '<span style="opacity: 0.6; font-size: 0.85rem;">Drop players here...</span>';
            } else {
                teamBDiv.innerHTML = manualGameSetup.teamB.map((player, index) => `
                    <div class="assigned-player">
                        ${player.name}
                        <span style="opacity: 0.6; font-size: 0.75rem; margin-left: 4px;">(${player.originalTeamName})</span>
                        <button class="remove-player" onclick="removePlayerFromSide('teamB', ${index})" title="Remove">√ó</button>
                    </div>
                `).join('');
            }
        }

        function removePlayerFromSide(side, index) {
            if (side === 'teamA') {
                manualGameSetup.teamA.splice(index, 1);
            } else {
                manualGameSetup.teamB.splice(index, 1);
            }
            
            updateManualGameDisplay();
            renderPlanTeamPool();
        }

        function clearManualGameSetup() {
            manualGameSetup.teamA = [];
            manualGameSetup.teamB = [];
            document.getElementById('planNotes').value = '';
            updateManualGameDisplay();
            renderPlanTeamPool();
            addLog('üîÑ Plan setup cleared');
        }

        async function addGameToQueue() {
            console.log('addGameToQueue called');
            console.log('manualGameSetup:', manualGameSetup);
            
            if (!gameState) {
                showStatus('Load game first!', 'error');
                return;
            }
            
            const game = document.getElementById('planGameType').value;
            const playType = document.getElementById('planPlayType').value;
            const notes = document.getElementById('planNotes').value || '';
            
            if (manualGameSetup.teamA.length === 0 || manualGameSetup.teamB.length === 0) {
                showStatus('Both TEAM A and TEAM B need at least one player', 'error');
                return;
            }
            
            const queueEntry = {
                id: Date.now(),
                game: game,
                playType: playType,
                teams: [
                    {
                        id: 'TEAM_A',
                        name: 'TEAM A',
                        players: manualGameSetup.teamA.map(p => ({
                            id: p.id,
                            name: p.name,
                            originalTeamId: p.originalTeamId,
                            originalTeamName: p.originalTeamName
                        }))
                    },
                    {
                        id: 'TEAM_B',
                        name: 'TEAM B',
                        players: manualGameSetup.teamB.map(p => ({
                            id: p.id,
                            name: p.name,
                            originalTeamId: p.originalTeamId,
                            originalTeamName: p.originalTeamName
                        }))
                    }
                ],
                notes: notes,
                status: 'pending',
                createdAt: new Date().toISOString()
            };
            
            gameState.gameQueue = gameState.gameQueue || [];
            gameState.gameQueue.push(queueEntry);
            
            await saveGameState();
            updateGameQueue();
            clearManualGameSetup();
            
            const teamANames = queueEntry.teams[0].players.map(p => p.name).join(' & ');
            const teamBNames = queueEntry.teams[1].players.map(p => p.name).join(' & ');
            
            addLog(`üìã Added ${game} ${playType} to queue: ${teamANames} vs ${teamBNames}`, 'success');
            showStatus('Game added to queue!', 'success');
        }

        // ===== CONFIRM RESULT FUNCTIONS =====
        function updateQueuedGameSelect() {
            const select = document.getElementById('queuedGameSelect');
            
            if (!gameState?.gameQueue || gameState.gameQueue.length === 0) {
                select.innerHTML = '<option value="">-- No games in queue --</option>';
                document.getElementById('confirmContainer').style.display = 'none';
                return;
            }
            
            const pendingGames = gameState.gameQueue.filter(g => g.status === 'pending');
            
            if (pendingGames.length === 0) {
                select.innerHTML = '<option value="">-- No pending games --</option>';
                document.getElementById('confirmContainer').style.display = 'none';
                return;
            }
            
            select.innerHTML = '<option value="">-- Select a game to confirm --</option>' +
                pendingGames.map(game => {
                    const teamNames = game.teams.map(t => t.name).join(' vs ');
                    return `<option value="${game.id}">${game.game} ${game.playType} - ${teamNames}</option>`;
                }).join('');
        }

        function loadQueuedGame() {
            const select = document.getElementById('queuedGameSelect');
            const gameId = parseInt(select.value);
            
            if (!gameId) {
                document.getElementById('confirmContainer').style.display = 'none';
                selectedQueuedGame = null;
                return;
            }
            
            selectedQueuedGame = gameState.gameQueue.find(g => g.id === gameId);
            
            if (!selectedQueuedGame) {
                showStatus('Game not found', 'error');
                return;
            }
            
            const infoDiv = document.getElementById('confirmGameInfo');
            infoDiv.innerHTML = `
                <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 5px;">
                    <strong>${selectedQueuedGame.game} - ${selectedQueuedGame.playType}</strong><br>
                    <small style="opacity: 0.8;">${selectedQueuedGame.notes || 'No notes'}</small>
                </div>
            `;
            
            const isTwoTeamMatch = selectedQueuedGame.teams.length === 2;
            const inputType = isTwoTeamMatch ? 'radio' : 'checkbox';
            const inputName = isTwoTeamMatch ? 'winner-selection' : '';
            
            const teamsDiv = document.getElementById('confirmTeamsDisplay');
            
            const explanationText = isTwoTeamMatch 
                ? '<p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 10px;">Select the winning team:</p>'
                : '<p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 10px;">Check all teams that won together (they will be counted as allied winners):</p>';
            
            teamsDiv.innerHTML = explanationText + selectedQueuedGame.teams.map((team, index) => `
                <div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 5px;">
                    <label class="winner-label">
                        <input type="${inputType}" 
                               ${inputName ? `name="${inputName}"` : ''} 
                               class="winner-checkbox" 
                               id="winner-${index}" 
                               value="${team.id}">
                        <strong>${team.name}</strong>
                        <span style="opacity: 0.8; font-size: 0.85rem;">
                            (${team.players.map(p => p.name).join(', ')})
                        </span>
                    </label>
                </div>
            `).join('');
            
            document.getElementById('confirmContainer').style.display = 'block';
        }

        async function confirmGameResult() {
            if (!selectedQueuedGame) {
                showStatus('Please select a game to confirm', 'error');
                return;
            }
            
            const checkedInputs = Array.from(document.querySelectorAll('input[class="winner-checkbox"]:checked'));
            
            if (checkedInputs.length === 0) {
                showStatus('Please select at least one winning team', 'error');
                return;
            }
            
            const isTwoTeamMatch = selectedQueuedGame.teams.length === 2;
            if (isTwoTeamMatch && checkedInputs.length > 1) {
                showStatus('Error: Only one team can win in a two-team match', 'error');
                return;
            }
            
            const winningSides = checkedInputs.map(input => input.value);
            const resultNotes = document.getElementById('confirmNotes').value || '';
            
            const winningPlayers = [];
            winningSides.forEach(side => {
                const virtualTeam = selectedQueuedGame.teams.find(t => t.id === side);
                if (virtualTeam) {
                    winningPlayers.push(...virtualTeam.players);
                }
            });
            
            const winningTeamIds = [...new Set(winningPlayers.map(p => p.originalTeamId))];
            
            if (winningTeamIds.length === 0) {
                showStatus('Error: Could not determine winning teams', 'error');
                return;
            }
            
            const firstWinningTeamId = winningTeamIds[0];
            const winningTeam = gameState.teams.find(t => t.id === firstWinningTeamId);
            
            if (!winningTeam) {
                showStatus('Error: Winning team not found!', 'error');
                return;
            }
            
            const result = {
                id: (gameState.gameHistory?.length || 0) + 1,
                game: selectedQueuedGame.game,
                playType: selectedQueuedGame.playType,
                matchup: {
                    teamA: selectedQueuedGame.teams[0].players.map(p => ({
                        name: p.name,
                        originalTeam: p.originalTeamName
                    })),
                    teamB: selectedQueuedGame.teams[1].players.map(p => ({
                        name: p.name,
                        originalTeam: p.originalTeamName
                    }))
                },
                winningSide: winningSides[0],
                winningPlayers: winningPlayers.map(p => ({
                    name: p.name,
                    originalTeamId: p.originalTeamId
                })),
                winningTeamIds: winningTeamIds,
                queuedGameId: selectedQueuedGame.id,
                planNotes: selectedQueuedGame.notes || '',
                resultNotes: resultNotes,
                timestamp: new Date().toISOString()
            };
            
            gameState.gameHistory = gameState.gameHistory || [];
            gameState.gameHistory.push(result);
            gameState.gamesPlayed = (gameState.gamesPlayed || 0) + 1;
            gameState.currentRound = Math.ceil(gameState.gamesPlayed / gameState.teams.length);
            
            winningTeamIds.forEach(teamId => {
                const team = gameState.teams.find(t => t.id === teamId);
                if (team) {
                    team.gamesWon = (team.gamesWon || 0) + 1;
                }
            });
            
            const queuedGame = gameState.gameQueue.find(g => g.id === selectedQueuedGame.id);
            if (queuedGame) {
                queuedGame.status = 'completed';
                queuedGame.completedAt = new Date().toISOString();
                queuedGame.resultId = result.id;
            }
            
            gameState.currentTurn = {
                teamId: firstWinningTeamId,
                needsPlacement: true,
                gameResultId: result.id,
                startTime: new Date().toISOString()
            };
            
            await saveGameState();
            updateDisplay();
            updateGameQueue();
            
            const teamANames = selectedQueuedGame.teams[0].players.map(p => p.name).join(' & ');
            const teamBNames = selectedQueuedGame.teams[1].players.map(p => p.name).join(' & ');
            const winningNames = winningPlayers.map(p => p.name).join(' & ');
            
            const logMessage = `üèÜ ${winningNames} won ${selectedQueuedGame.game} ${selectedQueuedGame.playType}. Match was: ${teamANames} vs ${teamBNames}`;
            
            addLog(logMessage, 'success');
            showStatus(`${winningTeam.name}'s turn to place a plate!`, 'info');
            
            document.getElementById('confirmContainer').style.display = 'none';
            document.getElementById('queuedGameSelect').value = '';
            document.getElementById('confirmNotes').value = '';
            selectedQueuedGame = null;
        }

        function updateGameQueue() {
            const container = document.getElementById('gameQueue');
            const countSpan = document.getElementById('queueCount');
            
            if (!gameState?.gameQueue || gameState.gameQueue.length === 0) {
                container.innerHTML = '<p style="text-align: center; opacity: 0.7; font-style: italic; font-size: 0.85rem;">No games in queue</p>';
                countSpan.textContent = '0';
                return;
            }
            
            const pendingGames = gameState.gameQueue.filter(g => g.status === 'pending');
            countSpan.textContent = pendingGames.length.toString();
            
            if (pendingGames.length === 0) {
                container.innerHTML = '<p style="text-align: center; opacity: 0.7; font-style: italic; font-size: 0.85rem;">No pending games</p>';
                return;
            }
            
            container.innerHTML = pendingGames.map(game => {
                const teamNames = game.teams.map(t => t.name).join(' vs ');
                return `
                    <div class="queued-game ${game.status}" onclick="selectQueuedGameFromList(${game.id})">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <strong style="font-size: 0.9rem;">${game.game} - ${game.playType}</strong>
                            <button onclick="event.stopPropagation(); removeFromQueue(${game.id})" 
                                    style="background: rgba(239, 68, 68, 0.8); color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px; line-height: 1; padding: 0;">√ó</button>
                        </div>
                        <div style="font-size: 0.85rem; opacity: 0.9;">${teamNames}</div>
                        ${game.notes ? `<div style="font-size: 0.75rem; opacity: 0.7; margin-top: 3px;">${game.notes}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function selectQueuedGameFromList(gameId) {
            switchTab('confirm');
            document.getElementById('queuedGameSelect').value = gameId;
            loadQueuedGame();
        }

        async function removeFromQueue(gameId) {
            if (!confirm('Remove this game from queue?')) return;
            
            gameState.gameQueue = gameState.gameQueue.filter(g => g.id !== gameId);
            await saveGameState();
            updateGameQueue();
            updateQueuedGameSelect();
            addLog(`üóëÔ∏è Removed game from queue`, 'success');
        }

        // ===== BOARD FUNCTIONS =====
        function canPlaceAt(q, r, teamId) {
            if (!gameState || !boardModule) return false;
            
            const teamPlates = Object.entries(gameState.board || {})
                .filter(([_, occupier]) => occupier === teamId)
                .map(([coord, _]) => coord);
            
            const occupiedHexes = Object.keys(gameState.board || {});
            
            return boardModule.canPlaceAt(q, r, teamPlates, occupiedHexes);
        }

        function handleHexClick(q, r) {
            if (!gameState?.currentTurn) {
                showStatus('No active turn. Confirm a game result first.', 'error');
                return;
            }
            
            const teamId = gameState.currentTurn.teamId;
            const coord = `q${q}r${r}`;
            
            if (!canPlaceAt(q, r, teamId)) {
                showStatus(`Cannot place plate at ${coord}`, 'error');
                return;
            }
            
            if (confirm(`Place plate for Team ${teamId} at ${coord}?`)) {
                placePlate(q, r, teamId);
            }
        }

        async function placePlate(q, r, teamId) {
            const coord = `q${q}r${r}`;
            
            gameState.board[coord] = teamId;
            
            const hexType = boardModule.getHexType(q, r);
            if (hexType === 'high-value' || hexType === 'center') {
                gameState.heartHexControl = gameState.heartHexControl || {};
                gameState.heartHexControl[coord] = teamId;
                addLog(`‚ù§Ô∏è Team ${teamId} captured heart hex ${coord}!`, 'success');
            }
            
            calculatePoints();
            gameState.currentTurn.needsPlacement = false;
            gameState.currentTurn = null;
            
            checkWinCondition();
            await saveGameState();
            
            addLog(`‚úÖ Team ${teamId} placed plate at ${coord}`, 'success');
            updateDisplay();
        }

        function calculatePoints() {
            if (!gameState?.teams || !boardModule) return;
            
            gameState.teams.forEach(team => {
                const teamPlates = Object.entries(gameState.board || {})
                    .filter(([_, occupier]) => occupier === team.id)
                    .map(([coord, _]) => coord);
                
                team.points = boardModule.calculateTeamPoints(teamPlates);
                
                Object.entries(gameState.heartHexControl || {}).forEach(([heartHex, controllingTeam]) => {
                    if (controllingTeam === team.id) {
                        const matches = heartHex.match(/-?\d+/g);
                        if (matches) {
                            const [q, r] = matches.map(Number);
                            team.points += boardModule.getHexType(q, r) === 'center' ? 2 : 1;
                        }
                    }
                });
            });
        }

        function checkWinCondition() {
            if (!gameState?.teams) return;
            
            const winner = gameState.teams.find(team => team.points >= gameState.winCondition);
            if (winner) {
                gameState.gamePhase = 'finished';
                gameState.finishedAt = new Date().toISOString();
                addLog(`üèÜ GAME OVER! ${winner.name} wins with ${winner.points} points!`, 'success');
                showStatus(`üèÜ ${winner.name} wins the game!`, 'success');
            }
        }

        function highlightValidPlacements() {
            if (!gameState?.currentTurn) {
                showStatus('No active turn', 'error');
                return;
            }
            
            clearHighlights();
            
            const teamId = gameState.currentTurn.teamId;
            const coordinates = boardModule.generateHexCoordinates();
            
            coordinates.forEach(([q, r]) => {
                if (canPlaceAt(q, r, teamId)) {
                    const coord = `q${q}r${r}`;
                    const hexElement = document.querySelector(`[data-coord="${coord}"]`);
                    if (hexElement) {
                        hexElement.classList.add('can-place-highlight');
                    }
                }
            });
            
            addLog(`üîç Showing valid placements for Team ${teamId}`);
        }

        function clearHighlights() {
            document.querySelectorAll('.board-hex.can-place-highlight').forEach(hex => {
                hex.classList.remove('can-place-highlight');
            });
        }

        // ===== DISPLAY UPDATES =====
        function updateDisplay() {
            if (boardRenderer && gameState) {
                boardRenderer.render(gameState);
                
                document.querySelectorAll('.board-hex').forEach(hex => {
                    const coord = hex.dataset.coord;
                    if (coord) {
                        const matches = coord.match(/-?\d+/g);
                        if (matches) {
                            const [q, r] = matches.map(Number);
                            hex.addEventListener('click', () => handleHexClick(q, r));
                        }
                    }
                });
            }
            
            updateTeamsList();
            updateCurrentTurnInfo();
            updateStatistics();
            updateGameQueue();
        }

        function updateTeamsList() {
            const container = document.getElementById('teamsList');
            
            if (!gameState?.teams) {
                container.innerHTML = '<p style="text-align: center; opacity: 0.7; font-style: italic;">Initialize game to see teams</p>';
                return;
            }
            
            const sortedTeams = [...gameState.teams].sort((a, b) => (b.points || 0) - (a.points || 0));
            
            container.innerHTML = sortedTeams.map((team, index) => {
                const isActive = gameState.currentTurn?.teamId === team.id;
                const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                
                return `
                    <div class="team-card team${team.id} ${isActive ? 'active' : ''}">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${rankIcon} ${team.name}</strong><br>
                                <small>${team.players.map(p => p.name).join(' & ')}</small>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.3rem; font-weight: bold;">${team.points || 0}</div>
                                <div style="font-size: 0.8rem; opacity: 0.8;">${team.gamesWon || 0} wins</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateCurrentTurnInfo() {
            const container = document.getElementById('currentTurnInfo');
            
            if (!gameState?.currentTurn) {
                container.innerHTML = '<strong>‚è≥ No active turn - Confirm a game result to start</strong>';
                return;
            }
            
            const team = gameState.teams.find(t => t.id === gameState.currentTurn.teamId);
            container.innerHTML = `
                <strong>üéØ ${team?.name}'s Turn</strong><br>
                <small>${team?.players.map(p => p.name).join(' & ')}</small><br>
                <div style="margin-top: 8px; color: #4ade80;">
                    ${gameState.currentTurn.needsPlacement ? 'üìç Click a hex to place plate' : '‚úÖ Placement complete'}
                </div>
            `;
        }

        function updateStatistics() {
            if (!gameState) {
                document.getElementById('statGamesPlayed').textContent = '0';
                document.getElementById('statRound').textContent = '0';
                document.getElementById('statPlates').textContent = '0';
                document.getElementById('statHearts').textContent = '0';
                return;
            }
            
            document.getElementById('statGamesPlayed').textContent = gameState.gamesPlayed || 0;
            document.getElementById('statRound').textContent = gameState.currentRound || 0;
            document.getElementById('statPlates').textContent = Object.keys(gameState.board || {}).length;
            document.getElementById('statHearts').textContent = Object.keys(gameState.heartHexControl || {}).length;
        }

        // ===== UTILITY =====
        function exportGameState() {
            if (!gameState) {
                showStatus('No game to export', 'error');
                return;
            }
            
            const dataStr = JSON.stringify(gameState, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `game-${gameState.gameId}-${new Date().toISOString().slice(0, 10)}.json`;
            link.click();
            
            addLog('üì• Game state exported', 'success');
            showStatus('Game exported successfully!', 'success');
        }

        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message ${type}`;
            statusEl.style.display = 'block';
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }

        function addLog(message, type = 'info') {
            const log = document.getElementById('gameLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span style="opacity: 0.7;">[${timestamp}]</span> ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog() {
            document.getElementById('gameLog').innerHTML = '<div class="log-entry">Log cleared...</div>';
        }

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', function() {
            addLog('üëë God Mode Admin Panel Ready');
            
            initializeBoardModules();
            
            const urlParams = new URLSearchParams(window.location.search);
            const gameId = urlParams.get('gameId') || urlParams.get('game');
            if (gameId) {
                document.getElementById('gameId').value = gameId;
                setTimeout(() => loadGame(), 1000);
            } else {
                const dateStr = new Date().toISOString().slice(0, 10);
                document.getElementById('gameId').value = `game-${dateStr}`;
            }
            
            updateManualGameDisplay();
        });

        setInterval(() => {
            if (gameState?.initialized) {
                saveGameState();
            }
        }, 30000);
    </script>
</body>
</html>